#summary The CEL Quest System

= Introduction =

CEL has a powerful quest system. A quest is basically a state machine which can jump from one state to the other when certain things happen.

= Details =

The basic structure of a quest is that it has a number of states. Every state then has a number of triggers. When a trigger fires it will execute a number of rewards.

In addition a quest also supports sequences which are timed operations that can be used for animation. Some examples of useful sequences are: opening doors, glowing lights, moving platforms, ...

A few example triggers:

 * _message_: a message is received from some source. You can specify the id mask of the messages you want to listen too.
 * _sequencefinish_: a sequence finishes executing.
 * _timeout_: a certain time has elapsed.
 * _meshsel_: a mesh was selected with the mouse.
 * _inventory_: something happened on an inventory.
 * _propertychange_: a property changes.
 * _watch_: wait until a certain entity comes in range.
 * ...

A few example rewards:

 * _debugprint_: for debugging. Print out a message on the console.
 * _changeproperty_: change a property of an entity.
 * _sequence_: start an animation sequence.
 * _createentity_: create a new entity.
 * _destroyentity_: destroy an entity.
 * _inventory_: manipulate an inventory.
 * _newstate_: switch to a new state.
 * ...

= Examples =

Here we show a few quest examples.

== Simple Quest ==

{{{
<addon plugin="cel.addons.questdef" >
  <quest name="clickerObject">
    <state name="init">
      <trigger type="message">
        <fireon entity="$this" mask="ares.activate" />
        <reward type="debugprint" message="=?counter" />
        <reward type="changeproperty" entity="$this" property="counter" diff="1" />
        <reward type="newstate" state="init" />
      </trigger>
    </state>
  </quest>
</addon>
}}}

This is a very simple quest that just has a single state (named 'init'). This state has a single trigger that listens to a message with mask 'ares.activate'. This message will be sent by the Ares game whenever an entity is activated. The message is sent to the entity so if you attach this quest to an entity then it will know how to respond to activation.

Whenever the entity is activated there are three rewards to are executed:
 * First a message is printed on the console for debugging purposes. This message will be the value of the 'counter' attribute in the entity (the string '?counter' is an expression that evaluates the attribute 'counter' in the current entity).
 * Secondly the 'counter' property is modified by adding 1 to it.
 * And finally the state of the quest is reset to 'init'. This is needed because otherwise the state isn't reactivated and the quest would simply stop.

== Proximity Quest ==

{{{
<addon plugin="cel.addons.questdef" >
  <quest name="watchPlayerQuest">
    <state name="init">
      <trigger type="watch">
        <fireon entity="$this" target="player" checktime="1000" radius="5" />
        <reward type="message" entity="world" id="ares.messagebox">
          <par name="message" string="You enter a very dangerous area!" />
        </reward>
        <reward type="newstate" state="stop" />
      </trigger>
    </state>
    <state name="stop" />
  </quest>
</addon>
}}}

This quest has two states. In the initial state it will watch out for the player using the 'watch' trigger. It is set up in such a manner that it will look for the player once every second. If the player is closer to this entity then 5 units then the trigger will fire and the two rewards will execute:
 * First a message is sent to the Ares game logic (which is kept in the 'world' entity). This message is the 'ares.messagebox' message and when Ares receives this message it will show a message box to the user with a certain message. The message is given with the 'message' parameter for the reward.
 * Then the state is set to 'stop at which point the quest simply stops executing.

== A Bigger Example: A Player Quest ==

In this example I demonstrate how you could make a quest that actually operates as a quest for the player. i.e. it involves a story line quest that the player has to solve. Let's call these quests 'Story Quests' to distinguish them from the more mundane quests that are used for managing entity behaviour on a lower level. Nevertheless these quests are going to be made using the same quest system.

{{{
<addon plugin="cel.addons.questdef" >
  <quest name="findTheSecretNote">

    <state name="init">
      <oninit>
        <reward type="message" id="ares.logentry">
          <par name="logid" string="SECNOTE_intro" />
          <par name="message" string="You must go find a secret note. Perhaps look in the basement?" 
        </reward>
        <reward type="newstate" state="watchout" />
      </oninit>
    </state>

    <state name="watchout">
      <trigger type="entersector">
        <fireon entity="player" sector="cellBasement" />
        <reward type="message" id="ares.logentry">
          <par name="logid" string="SECNOTE_enterbasement" />
          <par name="message" string="As you enter the basement you get the impression that there was a fight recently. Perhaps you will find a clue here?" 
        </reward>
        <reward type="newstate" state="watchout" />
      </trigger>
      <trigger type="inventory">
        <fireon entity="player" child_entity="SecretNote" />
        <reward type="message" id="ares.logentry">
          <par name="logid" string="SECNOTE_gotnote" />
          <par name="message" string="You pick up a note. This looks like the secret note you had to find." 
        </reward>
        <reward type="newstate" state="finish" />
      </trigger>
    </state>

    <state name="finish">
      <oninit>
        <reward type="message" id="ares.finishquest">
          <par name="quest" string="findTheSecretNote" />
        </reward>
      </oninit>
    </state>

  </quest>
</addon>
}}}